<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - dyna analysis - dynamicdecoder/DynamicDecoderX.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">dynamicdecoder</a> - DynamicDecoderX.h<span style="font-size: 80%;"> (source / <a href="DynamicDecoderX.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">dyna analysis</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">28</td>
            <td class="headerCovTableEntry">29</td>
            <td class="headerCovTableEntryHi">96.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-05-05</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*---------------------------------------------------------------------------------------------*</a>
<span class="lineNum">       2 </span>            :  * Copyright (C) 2012 Daniel Bola√±os - www.bltek.com - Boulder Language Technologies           *
<span class="lineNum">       3 </span>            :  *                                                                                             *
<span class="lineNum">       4 </span>            :  * www.bavieca.org is the website of the Bavieca Speech Recognition Toolkit                    *
<span class="lineNum">       5 </span>            :  *                                                                                             *
<span class="lineNum">       6 </span>            :  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);                             *
<span class="lineNum">       7 </span>            :  * you may not use this file except in compliance with the License.                            *
<span class="lineNum">       8 </span>            :  * You may obtain a copy of the License at                                                     *
<span class="lineNum">       9 </span>            :  *                                                                                             *
<span class="lineNum">      10 </span>            :  *         http://www.apache.org/licenses/LICENSE-2.0                                          *
<span class="lineNum">      11 </span>            :  *                                                                                             *
<span class="lineNum">      12 </span>            :  * Unless required by applicable law or agreed to in writing, software                         *
<span class="lineNum">      13 </span>            :  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,                           *
<span class="lineNum">      14 </span>            :  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.                    *
<span class="lineNum">      15 </span>            :  * See the License for the specific language governing permissions and                         *
<span class="lineNum">      16 </span>            :  * limitations under the License.                                                              *
<span class="lineNum">      17 </span>            :  *---------------------------------------------------------------------------------------------*/
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #ifndef DYNAMICDECODERX_H
<span class="lineNum">      21 </span>            : #define DYNAMICDECODERX_H
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;float.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      26 </span>            : #include &lt;limits.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;vector&gt;
<span class="lineNum">      28 </span>            : using namespace std;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &lt;list&gt;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : #include &quot;Global.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;Vector.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;Matrix.h&quot;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #include &quot;DynamicNetworkX.h&quot;
<span class="lineNum">      38 </span>            : //----------------------------------- 
<span class="lineNum">      39 </span>            : #include &quot;Global.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;HMMManager.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;LexiconManager.h&quot;
<span class="lineNum">      42 </span>            : //-----------------------------------
<span class="lineNum">      43 </span>            : //#include &quot;HypothesisLattice.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;LexiconManager.h&quot;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : namespace Bavieca {
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : class BestPath;
<span class="lineNum">      49 </span>            : class HMMManager;
<span class="lineNum">      50 </span>            : class PhoneSet;
<span class="lineNum">      51 </span>            : class LMLookAhead;
<span class="lineNum">      52 </span>            : class LMFSM;
<span class="lineNum">      53 </span>            : class LMManager;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : #define NUMBER_BINS_HISTOGRAM                                                   50
<span class="lineNum">      56 </span>            : #define NUMBER_BINS_HISTOGRAM_WITHIN_NODE                       100
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : // language model transition (auxiliar structure)
<span class="lineNum">      59 </span>            : typedef struct {
<span class="lineNum">      60 </span>            :         int iLMState;                           // next lm-state
<span class="lineNum">      61 </span>            :         float fScoreLM;                 // associated score
<span class="lineNum">      62 </span>            : } LMTransition;
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : // entry in the hash table that keeps unique word sequences (lattice generation)
<span class="lineNum">      65 </span>            : typedef struct _WSHashEntry {
<span class="lineNum">      66 </span>            :         int iTime;                                      // time frame of last insertion (-1 initially)
<span class="lineNum">      67 </span>            :         int iLexUnits;                          // number of lexical units in the word sequence
<span class="lineNum">      68 </span>            :         int *iLexUnit;                          // lexical units in the word-sequence
<span class="lineNum">      69 </span>            :         int iNext;                                      // next table entry (to handle collisions)
<span class="lineNum">      70 </span>            : } WSHashEntry;
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : // structure to keep the lexical unit history
<span class="lineNum">      73 </span>            : typedef struct _HistoryItem {
<span class="lineNum">      74 </span>            :    int iLexUnitPron;                    // lexical unit (including alternative pronunciations)
<span class="lineNum">      75 </span>            :    int iEndFrame;                               // ending frame (the start frame can  be obtained from the previous lexical unit)
<span class="lineNum">      76 </span>            :    float fScore;                                // global score (accumulated across the whole utterance) includes lm and am scores
<span class="lineNum">      77 </span>            :    int iPrev;                                   // previous history item
<span class="lineNum">      78 </span>            :    int iActive;                         // last time the item was active (part of an active token's history) (garbage collection)
<span class="lineNum">      79 </span>            :    int iWGToken;                                // best N paths that arrive at this word history item (each of them has a backpointer)
<span class="lineNum">      80 </span>            : } HistoryItem;
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : typedef vector&lt;HistoryItem*&gt; VHistoryItem;
<span class="lineNum">      83 </span>            : typedef list&lt;HistoryItem*&gt; LHistoryItem;
<span class="lineNum">      84 </span>            : typedef map&lt;HistoryItem*,bool&gt; MHistoryItem;
<span class="lineNum">      85 </span>            : //typedef map&lt;HistoryItem*,LNode*&gt; MHistoryItemLNode;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : // word-graph token (word-graph generation)
<span class="lineNum">      88 </span>            : typedef struct _WGToken {
<span class="lineNum">      89 </span>            :         int iWordSequence;                              // index in the hash table containing unique word sequences
<span class="lineNum">      90 </span>            :         int iLexUnitPron;                                       // lexical-unit at the time this token was created (in case it was known)
<span class="lineNum">      91 </span>            :         //add support for this field and remove added code used for debugging
<span class="lineNum">      92 </span>            :         float fScore;                                           // path score
<span class="lineNum">      93 </span>            :         int iHistoryItem;                                       // index of the previous item in the history
<span class="lineNum">      94 </span>            :         int iActive;                                            // last time the token was active (part of an active token's history) (garbage collection)
<span class="lineNum">      95 </span>            :         int iPrev;                                                      // previous token in the list of available tokens (memory management and garbage collection)    
<span class="lineNum">      96 </span>            : } WGToken;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : typedef list&lt;WGToken*&gt; LWGToken;
<span class="lineNum">      99 </span>            : typedef vector&lt;WGToken*&gt; VWGToken;
<span class="lineNum">     100 </span>            : typedef map&lt;WGToken*,bool&gt; MWGToken;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : // token
<span class="lineNum">     103 </span>            : typedef struct {
<span class="lineNum">     104 </span>            :         float fScore;                                           // path score
<span class="lineNum">     105 </span>            :         HMMStateDecoding *state;                // hmm-state
<span class="lineNum">     106 </span>            :         int iLMState;                                           // language model state
<span class="lineNum">     107 </span>            :         int iLexUnitPron;                                       // lexical unit (including alternative pronunciations)
<span class="lineNum">     108 </span>            :         int iNode;                                                      // index of the node where the token is
<span class="lineNum">     109 </span>            :         int iHistoryItem;                                       // index of the history item
<span class="lineNum">     110 </span>            : } Token;
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : // active token
<span class="lineNum">     113 </span>            : typedef struct {
<span class="lineNum">     114 </span>            :         int iLMState;                                           // language model state
<span class="lineNum">     115 </span>            :         int iToken;                                                     // active token
<span class="lineNum">     116 </span>            : } ActiveToken;
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : /**
<span class="lineNum">     119 </span>            :         @author daniel &lt;dani.bolanos@gmail.com&gt;
<span class="lineNum">     120 </span>            : */
<span class="lineNum">     121 </span>            : class DynamicDecoderX {
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            :         private:
<span class="lineNum">     124 </span>            :         
<span class="lineNum">     125 </span>            :                 PhoneSet *m_phoneSet;
<span class="lineNum">     126 </span>            :                 HMMManager *m_hmmManager;
<span class="lineNum">     127 </span>            :                 LexiconManager *m_lexiconManager;
<span class="lineNum">     128 </span>            :                 LMFSM *m_lmFSM;
<span class="lineNum">     129 </span>            :                 LMManager *m_lmManager;
<span class="lineNum">     130 </span>            :                 unsigned char m_iNGram;
<span class="lineNum">     131 </span>            :                 DynamicNetworkX *m_dynamicNetwork;
<span class="lineNum">     132 </span>            :                 
<span class="lineNum">     133 </span>            :                 // network properties
<span class="lineNum">     134 </span>            :                 int m_iArcs;
<span class="lineNum">     135 </span>            :                 DArc *m_arcs;
<span class="lineNum">     136 </span>            :                 int m_iNodes;
<span class="lineNum">     137 </span>            :                 DNode *m_nodes;
<span class="lineNum">     138 </span>            :                 
<span class="lineNum">     139 </span>            :                 // pruning parameters
<span class="lineNum">     140 </span>            :                 int m_iMaxActiveNodes;                          // maximum number of active arcs
<span class="lineNum">     141 </span>            :                 int m_iMaxActiveNodesWE;                        // maximum number of active arcs at word-ends
<span class="lineNum">     142 </span>            :                 int m_iMaxActiveTokensNode;             // maximum number of active tokens within an arc
<span class="lineNum">     143 </span>            :                 float m_fBeamWidthNodes;                        // beam width for all arcs
<span class="lineNum">     144 </span>            :                 float m_fBeamWidthNodesWE;                      // beam width for all arcs at word-ends
<span class="lineNum">     145 </span>            :                 float m_fBeamWidthTokensNode;           // beam width for all tokens within an arc
<span class="lineNum">     146 </span>            :                 
<span class="lineNum">     147 </span>            :                 // scaling factor
<span class="lineNum">     148 </span>            :                 float m_fLMScalingFactor;
<span class="lineNum">     149 </span>            :                 
<span class="lineNum">     150 </span>            :                 // current time frame
<span class="lineNum">     151 </span>            :                 int m_iTimeCurrent;
<span class="lineNum">     152 </span>            :                 
<span class="lineNum">     153 </span>            :                 bool m_bInitialized;
<span class="lineNum">     154 </span>            :                 
<span class="lineNum">     155 </span>            :                 // tokens
<span class="lineNum">     156 </span>            :                 int m_iTokensMax;                                               // number of tokens allocated
<span class="lineNum">     157 </span>            :                 Token *m_tokensCurrent;
<span class="lineNum">     158 </span>            :                 Token *m_tokensNext;
<span class="lineNum">     159 </span>            :                 int m_iTokensNext;
<span class="lineNum">     160 </span>            :                 
<span class="lineNum">     161 </span>            :                 // active nodes
<span class="lineNum">     162 </span>            :                 DNode **m_nodesActiveCurrent;
<span class="lineNum">     163 </span>            :                 DNode **m_nodesActiveNext;
<span class="lineNum">     164 </span>            :                 int m_iNodesActiveCurrent;
<span class="lineNum">     165 </span>            :                 int m_iNodesActiveNext;
<span class="lineNum">     166 </span>            :                 int m_iNodesActiveCurrentMax;
<span class="lineNum">     167 </span>            :                 int m_iNodesActiveNextMax;
<span class="lineNum">     168 </span>            :                 
<span class="lineNum">     169 </span>            :                 // active tokens
<span class="lineNum">     170 </span>            :                 int m_iTokensNodeMax;
<span class="lineNum">     171 </span>            :                 ActiveToken *m_activeTokenCurrent;
<span class="lineNum">     172 </span>            :                 ActiveToken *m_activeTokenNext;
<span class="lineNum">     173 </span>            :                 int m_iActiveTokenTables;
<span class="lineNum">     174 </span>            :                 int m_iActiveTokenMax;
<span class="lineNum">     175 </span>            :                 
<span class="lineNum">     176 </span>            :                 float m_fScoreBest;
<span class="lineNum">     177 </span>            :                 float m_fScoreBestWE;
<span class="lineNum">     178 </span>            :                 
<span class="lineNum">     179 </span>            :                 // history item management
<span class="lineNum">     180 </span>            :                 unsigned int m_iHistoryItems;                                   // number of history items allocated
<span class="lineNum">     181 </span>            :                 HistoryItem *m_historyItems;                                    // history items allocated
<span class="lineNum">     182 </span>            :                 int m_iHistoryItemBegSentence;                          // initial history item
<span class="lineNum">     183 </span>            :                 int m_iHistoryItemAvailable;                                    //      next history item available to be used
<span class="lineNum">     184 </span>            :                 int m_iTimeGarbageCollectionLast;                       // last time frame the garbage collection was run
<span class="lineNum">     185 </span>            :                 // auxiliar arrays (used for token expansion)
<span class="lineNum">     186 </span>            :                 int *m_iHistoryItemsAuxBuffer;
<span class="lineNum">     187 </span>            :                 int *m_iHistoryItemsAux;
<span class="lineNum">     188 </span>            :                 int m_iHistoryItemsAuxSize;
<span class="lineNum">     189 </span>            :                 
<span class="lineNum">     190 </span>            :                 // word-graph generation
<span class="lineNum">     191 </span>            :                 bool m_bLatticeGeneration;                              // whether to generate a word-graph     
<span class="lineNum">     192 </span>            :                 int m_iMaxWordSequencesState;                   // maximum number of word sequences arriving at any state       
<span class="lineNum">     193 </span>            :                 map&lt;int,pair&lt;float,int&gt; &gt; m_mWSHistoryItem;
<span class="lineNum">     194 </span>            :                 list&lt;int&gt; m_lHistoryItem;
<span class="lineNum">     195 </span>            :                                 
<span class="lineNum">     196 </span>            :                 // hash table for hashing word sequences
<span class="lineNum">     197 </span>            :                 unsigned int m_iWSHashBuckets;          // # buckets in the hash table
<span class="lineNum">     198 </span>            :                 unsigned int m_iWSHashEntries;          //      # entries in the hash table (#entries = #buckets + #unique word sequences)
<span class="lineNum">     199 </span>            :                 WSHashEntry *m_wshashEntries;                                                   // hash table
<span class="lineNum">     200 </span>            :                 int m_iWSHashEntryCollisionAvailable;           // next available entry in the hash table to store collisions
<span class="lineNum">     201 </span>            :                 
<span class="lineNum">     202 </span>            :                 // utterance information
<span class="lineNum">     203 </span>            :                 int m_iFeatureVectorsUtterance; 
<span class="lineNum">     204 </span>            :                 
<span class="lineNum">     205 </span>            :                 // unknown lexical unit
<span class="lineNum">     206 </span>            :                 int m_iLexUnitPronUnknown;
<span class="lineNum">     207 </span>            :                 
<span class="lineNum">     208 </span>            :                 // language model look-ahead
<span class="lineNum">     209 </span>            :                 LMLookAhead *m_lmLookAhead;
<a name="210"><span class="lineNum">     210 </span>            :                 </a>
<span class="lineNum">     211 </span>            :                 // create a new token
<span class="lineNum">     212 </span><span class="lineCov">   17968603 :                 inline int newToken() { </span>
<span class="lineNum">     213 </span>            :                 
<span class="lineNum">     214 </span><span class="lineCov">   17968603 :                         assert(m_iTokensNext &lt; m_iTokensMax);</span>
<span class="lineNum">     215 </span><span class="lineCov">   17968603 :                         int iToken = m_iTokensNext;     </span>
<span class="lineNum">     216 </span><span class="lineCov">   17968603 :                         ++m_iTokensNext;</span>
<span class="lineNum">     217 </span>            :                 
<span class="lineNum">     218 </span><span class="lineCov">   17968603 :                         return iToken;</span>
<a name="219"><span class="lineNum">     219 </span>            :                 }</a>
<span class="lineNum">     220 </span>            :                 
<span class="lineNum">     221 </span><span class="lineCov">    8370213 :                 inline int newActiveTokenTable() {</span>
<span class="lineNum">     222 </span>            :                 
<span class="lineNum">     223 </span><span class="lineCov">    8370213 :                         assert(m_iActiveTokenTables+m_iTokensNodeMax &lt; m_iActiveTokenMax);</span>
<span class="lineNum">     224 </span><span class="lineCov">    8370213 :                         m_iActiveTokenTables += m_iTokensNodeMax; </span>
<span class="lineNum">     225 </span>            :                 
<span class="lineNum">     226 </span><span class="lineCov">    8370213 :                         return m_iActiveTokenTables-m_iTokensNodeMax;</span>
<span class="lineNum">     227 </span>            :                 }
<a name="228"><span class="lineNum">     228 </span>            :                 </a>
<span class="lineNum">     229 </span>            :                 // return an unused history item
<span class="lineNum">     230 </span><span class="lineCov">     405776 :                 inline int newHistoryItem() {</span>
<span class="lineNum">     231 </span>            :                 
<span class="lineNum">     232 </span><span class="lineCov">     405776 :                         if (m_iHistoryItemAvailable == -1) {</span>
<span class="lineNum">     233 </span><span class="lineCov">         41 :                                 if (m_bLatticeGeneration == false) {</span>
<span class="lineNum">     234 </span><span class="lineCov">         41 :                                         historyItemGarbageCollection();</span>
<span class="lineNum">     235 </span>            :                                 } else {
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :                                         historyItemGarbageCollectionLattice(true,false);</span>
<span class="lineNum">     237 </span>            :                                 }
<span class="lineNum">     238 </span><span class="lineCov">         41 :                                 assert(m_iHistoryItemAvailable != -1);</span>
<span class="lineNum">     239 </span>            :                         }
<span class="lineNum">     240 </span>            :                         
<span class="lineNum">     241 </span><span class="lineCov">     405776 :                         int iReturn = m_iHistoryItemAvailable;</span>
<span class="lineNum">     242 </span><span class="lineCov">     405776 :                         m_historyItems[m_iHistoryItemAvailable].iWGToken = -1;</span>
<span class="lineNum">     243 </span><span class="lineCov">     405776 :                         m_iHistoryItemAvailable = m_historyItems[m_iHistoryItemAvailable].iPrev; </span>
<span class="lineNum">     244 </span>            :                 
<span class="lineNum">     245 </span><span class="lineCov">     405776 :                         return iReturn;</span>
<span class="lineNum">     246 </span>            :                 }
<span class="lineNum">     247 </span>            :                 
<span class="lineNum">     248 </span>            :                 // return whether a history item is inactive (debugging)
<span class="lineNum">     249 </span>            :                 inline bool inactive(int iHistoryItem) {
<span class="lineNum">     250 </span>            :                 
<span class="lineNum">     251 </span>            :                         int iAux = m_iHistoryItemAvailable;
<span class="lineNum">     252 </span>            :                         while(iAux != -1) {
<span class="lineNum">     253 </span>            :                                 if (iAux == iHistoryItem) {
<span class="lineNum">     254 </span>            :                                         return true;
<span class="lineNum">     255 </span>            :                                 }
<span class="lineNum">     256 </span>            :                                 iAux = m_historyItems[iAux].iPrev;
<span class="lineNum">     257 </span>            :                         }
<span class="lineNum">     258 </span>            :                         
<span class="lineNum">     259 </span>            :                         return false;
<span class="lineNum">     260 </span>            :                 }
<a name="261"><span class="lineNum">     261 </span>            :                 </a>
<span class="lineNum">     262 </span>            :                 // swap token tables (after processing a feature vector)
<span class="lineNum">     263 </span><span class="lineCov">       1876 :                 inline void swapTokenTables() {</span>
<span class="lineNum">     264 </span>            :                                 
<span class="lineNum">     265 </span>            :                         // swap token tables
<span class="lineNum">     266 </span><span class="lineCov">       1876 :                         Token *tokenAux = m_tokensCurrent;</span>
<span class="lineNum">     267 </span><span class="lineCov">       1876 :                         m_tokensCurrent = m_tokensNext;</span>
<span class="lineNum">     268 </span><span class="lineCov">       1876 :                         m_tokensNext = tokenAux;</span>
<span class="lineNum">     269 </span><span class="lineCov">       1876 :                         m_iTokensNext = 0;</span>
<span class="lineNum">     270 </span>            :                         
<span class="lineNum">     271 </span>            :                         // swap active-token tables
<span class="lineNum">     272 </span><span class="lineCov">       1876 :                         ActiveToken *activeTokenAux = m_activeTokenNext;</span>
<span class="lineNum">     273 </span><span class="lineCov">       1876 :                         m_activeTokenNext = m_activeTokenCurrent;</span>
<span class="lineNum">     274 </span><span class="lineCov">       1876 :                         m_activeTokenCurrent = activeTokenAux;</span>
<span class="lineNum">     275 </span><span class="lineCov">       1876 :                         m_iActiveTokenTables = 0;</span>
<span class="lineNum">     276 </span><span class="lineCov">       1876 :                 }               </span>
<span class="lineNum">     277 </span>            :                 
<span class="lineNum">     278 </span>            :                 // root-node expansion
<span class="lineNum">     279 </span>            :                 void expandRoot(VectorBase&lt;float&gt; &amp;vFeatureVector);
<span class="lineNum">     280 </span>            :                 
<span class="lineNum">     281 </span>            :                 // regular expansion
<span class="lineNum">     282 </span>            :                 void expand(VectorBase&lt;float&gt; &amp;vFeatureVector, int t);
<span class="lineNum">     283 </span>            :                 
<span class="lineNum">     284 </span>            :                 // expand a series of tokens to a hmm-state
<span class="lineNum">     285 </span>            :                 void expandToHMM(DNode *node, DArc *arcNext, VectorBase&lt;float&gt; &amp;vFeatureVector, int t);
<span class="lineNum">     286 </span>            :                 
<span class="lineNum">     287 </span>            :                 // expand a series of tokens to a hmm-state after obsering a new word
<span class="lineNum">     288 </span>            :                 void expandToHMMNewWord(DNode *node, DArc *arcNext, LexUnit *lexUnit, LMTransition *lmTransition, 
<span class="lineNum">     289 </span>            :                         VectorBase&lt;float&gt; &amp;vFeatureVector, int t);    
<span class="lineNum">     290 </span>            :                 
<span class="lineNum">     291 </span>            :                 // pruning (token based)
<span class="lineNum">     292 </span>            :                 void pruningOriginal();
<span class="lineNum">     293 </span>            :                 
<span class="lineNum">     294 </span>            :                 // pruning (token based)
<span class="lineNum">     295 </span>            :                 void pruning();         
<span class="lineNum">     296 </span>            :                 
<span class="lineNum">     297 </span>            :                 // marks unused history items as available
<span class="lineNum">     298 </span>            :                 void historyItemGarbageCollection();
<span class="lineNum">     299 </span>            :                                 
<span class="lineNum">     300 </span>            :                 // marks unused history items as available (lattice generation)
<span class="lineNum">     301 </span>            :                 void historyItemGarbageCollectionLattice(bool bRecycleHistoryItems, bool bRecycleWGTokens);
<span class="lineNum">     302 </span>            :                 
<span class="lineNum">     303 </span>            :                 // get the destination lexical units
<span class="lineNum">     304 </span>            :                 void getDestinationMonophoneLexUnits(DNode *node, VLexUnit &amp;vLexUnitDest);
<span class="lineNum">     305 </span>            :                 
<span class="lineNum">     306 </span>            :                 // prune active tokens that are not in the top-N within a node 
<span class="lineNum">     307 </span>            :                 void pruneExtraTokens(DNode *node);
<span class="lineNum">     308 </span>            :                 
<span class="lineNum">     309 </span>            :  
<span class="lineNum">     310 </span>            :  
<span class="lineNum">     311 </span>            :                 // compute the load factor of the hash table containing unque word sequences (debugging)
<span class="lineNum">     312 </span>            :                 float computeLoadFactorHashWordSequences(int *iBucketsUsed, int *iCollisions);          
<span class="lineNum">     313 </span>            :                 
<span class="lineNum">     314 </span>            :                 // shows hash-occupation information (debugging)
<span class="lineNum">     315 </span>            :                 void printHashsStats();
<span class="lineNum">     316 </span>            :                 
<span class="lineNum">     317 </span>            :                 // print the hash-contents 
<span class="lineNum">     318 </span>            :                 void printHashContents();       
<span class="lineNum">     319 </span>            :                 
<span class="lineNum">     320 </span>            :                 // keeps the best history item for each unique word-sequence (auxiliar method)
<span class="lineNum">     321 </span>            :                 void keepBestHistoryItem(int iHistoryItem);     
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :         public:
<span class="lineNum">     324 </span>            :                 
<span class="lineNum">     325 </span>            :                 // constructor
<span class="lineNum">     326 </span>            :                 DynamicDecoderX(PhoneSet *phoneSet, HMMManager *hmmManager, 
<span class="lineNum">     327 </span>            :                         LexiconManager *lexiconManager, LMManager *lmManager, float fLMScalingFactor, 
<span class="lineNum">     328 </span>            :                         DynamicNetworkX *dynamicNetwork, int iMaxActiveNodes, 
<span class="lineNum">     329 </span>            :                         int iMaxActiveNodesWE, int iMaxActiveTokensNode, float fBeamWidthNodes, 
<span class="lineNum">     330 </span>            :                         float fBeamWidthNodesWE, float fBeamWidthTokensNode, bool bWordGraphGeneration, 
<span class="lineNum">     331 </span>            :                         int iMaxWordSequencesState);
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :                 // destructor
<span class="lineNum">     334 </span>            :                 ~DynamicDecoderX();
<span class="lineNum">     335 </span>            :                 
<span class="lineNum">     336 </span>            :                 // initialization
<span class="lineNum">     337 </span>            :                 void initialize();
<span class="lineNum">     338 </span>            :                 
<span class="lineNum">     339 </span>            :                 // uninitialize
<span class="lineNum">     340 </span>            :                 void uninitialize();
<span class="lineNum">     341 </span>            :                 
<span class="lineNum">     342 </span>            :                 // begin utterance
<span class="lineNum">     343 </span>            :                 void beginUtterance();
<span class="lineNum">     344 </span>            :                 
<span class="lineNum">     345 </span>            :                 // end utterance
<span class="lineNum">     346 </span>            :                 void endUtterance();
<span class="lineNum">     347 </span>            :                 
<span class="lineNum">     348 </span>            :                 // process input feature vectors
<span class="lineNum">     349 </span>            :                 void process(MatrixBase&lt;float&gt; &amp;mFeatures);   
<span class="lineNum">     350 </span>            :                 
<span class="lineNum">     351 </span>            :                 // return the BestPath
<span class="lineNum">     352 </span>            :                 BestPath *getBestPath();
<span class="lineNum">     353 </span>            :                 
<span class="lineNum">     354 </span>            :                 // return a hypothesis lattice for the utterance
<span class="lineNum">     355 </span>            :                 //HypothesisLattice *getHypothesisLattice();
<span class="lineNum">     356 </span>            :                 
<span class="lineNum">     357 </span>            :                 // return the active lm-states at the current time (lm-state in active tokens)
<span class="lineNum">     358 </span>            :                 void getActiveLMStates(map&lt;int,bool&gt; &amp;mLMState);      
<span class="lineNum">     359 </span>            :                 
<span class="lineNum">     360 </span>            : };
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : };      // end-of-namespace
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
