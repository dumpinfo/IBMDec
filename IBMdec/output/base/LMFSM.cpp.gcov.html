<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - dyna analysis - base/LMFSM.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">base</a> - LMFSM.cpp<span style="font-size: 80%;"> (source / <a href="LMFSM.cpp.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">dyna analysis</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">252</td>
            <td class="headerCovTableEntry">386</td>
            <td class="headerCovTableEntryLo">65.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-05-05</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">66.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*---------------------------------------------------------------------------------------------*</a>
<span class="lineNum">       2 </span>            :  * Copyright (C) 2012 Daniel Bola√±os - www.bltek.com - Boulder Language Technologies           *
<span class="lineNum">       3 </span>            :  *                                                                                             *
<span class="lineNum">       4 </span>            :  * www.bavieca.org is the website of the Bavieca Speech Recognition Toolkit                    *
<span class="lineNum">       5 </span>            :  *                                                                                             *
<span class="lineNum">       6 </span>            :  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);                             *
<span class="lineNum">       7 </span>            :  * you may not use this file except in compliance with the License.                            *
<span class="lineNum">       8 </span>            :  * You may obtain a copy of the License at                                                     *
<span class="lineNum">       9 </span>            :  *                                                                                             *
<span class="lineNum">      10 </span>            :  *         http://www.apache.org/licenses/LICENSE-2.0                                          *
<span class="lineNum">      11 </span>            :  *                                                                                             *
<span class="lineNum">      12 </span>            :  * Unless required by applicable law or agreed to in writing, software                         *
<span class="lineNum">      13 </span>            :  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,                           *
<span class="lineNum">      14 </span>            :  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.                    *
<span class="lineNum">      15 </span>            :  * See the License for the specific language governing permissions and                         *
<span class="lineNum">      16 </span>            :  * limitations under the License.                                                              *
<span class="lineNum">      17 </span>            :  *---------------------------------------------------------------------------------------------*/
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;LMFSM.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;FileInput.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;FileOutput.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;IOBase.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;LMManager.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;LogMessage.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;TimeUtils.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : namespace Bavieca {
<a name="29"><span class="lineNum">      29 </span>            : </a>
<span class="lineNum">      30 </span>            : //constructor
<span class="lineNum">      31 </span><span class="lineCov">          1 : LMFSM::LMFSM(LexiconManager *lexiconManager) {</span>
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span><span class="lineCov">          1 :         m_lexiconManager = lexiconManager;</span>
<span class="lineNum">      34 </span><span class="lineCov">          1 :         m_bLoaded = false;</span>
<span class="lineNum">      35 </span><span class="lineCov">          1 :         m_iNGrams = NULL;</span>
<span class="lineNum">      36 </span><span class="lineCov">          1 :         m_iNGramOrder = -1;</span>
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span><span class="lineCov">          1 :         m_iLMStateInitial = -1;</span>
<span class="lineNum">      39 </span><span class="lineCov">          1 :         m_iLMStateFinal = -1;</span>
<span class="lineNum">      40 </span><span class="lineCov">          1 :         m_states = NULL;</span>
<span class="lineNum">      41 </span><span class="lineCov">          1 :         m_arcs = NULL;  </span>
<span class="lineNum">      42 </span><span class="lineCov">          1 :         m_iStates = 0;</span>
<span class="lineNum">      43 </span><span class="lineCov">          1 :         m_iArcs = 0;</span>
<span class="lineNum">      44 </span><span class="lineCov">          1 :         m_iArcsStandard = 0;</span>
<span class="lineNum">      45 </span><span class="lineCov">          1 :         m_iArcsBackoff = 0;             </span>
<span class="lineNum">      46 </span><span class="lineCov">          1 : }</span>
<a name="47"><span class="lineNum">      47 </span>            : </a>
<span class="lineNum">      48 </span>            : // destructor
<span class="lineNum">      49 </span><span class="lineCov">          1 : LMFSM::~LMFSM() {</span>
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span><span class="lineCov">          1 :         if (m_bLoaded) {</span>
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span><span class="lineCov">          1 :                 if (m_states) {</span>
<span class="lineNum">      54 </span><span class="lineCov">          1 :                         delete [] m_states;</span>
<span class="lineNum">      55 </span><span class="lineCov">          1 :                         m_states = NULL;</span>
<span class="lineNum">      56 </span>            :                 }
<span class="lineNum">      57 </span><span class="lineCov">          1 :                 if (m_arcs) {</span>
<span class="lineNum">      58 </span><span class="lineCov">          1 :                         delete [] m_arcs;</span>
<span class="lineNum">      59 </span><span class="lineCov">          1 :                         m_arcs = NULL;</span>
<span class="lineNum">      60 </span>            :                 }
<span class="lineNum">      61 </span>            :         
<span class="lineNum">      62 </span><span class="lineCov">          1 :                 m_iLMStateInitial = -1;</span>
<span class="lineNum">      63 </span><span class="lineCov">          1 :                 m_iLMStateFinal = -1;</span>
<span class="lineNum">      64 </span><span class="lineCov">          1 :                 m_iStates = 0;</span>
<span class="lineNum">      65 </span><span class="lineCov">          1 :                 m_iArcs = 0;</span>
<span class="lineNum">      66 </span><span class="lineCov">          1 :                 m_iArcsStandard = 0;</span>
<span class="lineNum">      67 </span><span class="lineCov">          1 :                 m_iArcsBackoff = 0;</span>
<span class="lineNum">      68 </span>            :         
<span class="lineNum">      69 </span><span class="lineCov">          1 :                 delete [] m_iNGrams;</span>
<span class="lineNum">      70 </span><span class="lineCov">          1 :                 m_bLoaded = false;</span>
<span class="lineNum">      71 </span>            :         }       
<span class="lineNum">      72 </span><span class="lineCov">          1 : }</span>
<a name="73"><span class="lineNum">      73 </span>            : </a>
<span class="lineNum">      74 </span>            : // build the FSM from the n-grams
<span class="lineNum">      75 </span><span class="lineCov">          1 : void LMFSM::build(LMARPA *lmARPA) {</span>
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span><span class="lineCov">          1 :         double dTimeBegin = TimeUtils::getTimeMilliseconds();</span>
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineCov">          1 :         m_iNGramOrder = lmARPA-&gt;getNGramOrder();</span>
<span class="lineNum">      80 </span>            :         //m_iNGramOrder = 0;
<span class="lineNum">      81 </span><span class="lineCov">          1 :         m_iNGrams = new int[m_iNGramOrder+1];</span>
<span class="lineNum">      82 </span><span class="lineCov">          4 :         for(int i=0; i&lt;m_iNGramOrder ; ++i) {</span>
<span class="lineNum">      83 </span><span class="lineCov">          3 :                 m_iNGrams[i] = lmARPA-&gt;getNGrams(i);</span>
<span class="lineNum">      84 </span>            :         }
<span class="lineNum">      85 </span><span class="lineCov">          1 :         unsigned int *iIgnoredNGrams = new unsigned int[m_iNGramOrder+1];</span>
<span class="lineNum">      86 </span><span class="lineCov">          5 :         for(int i=0; i&lt;=m_iNGramOrder ; ++i) {</span>
<span class="lineNum">      87 </span><span class="lineCov">          4 :                 iIgnoredNGrams[i] = 0;</span>
<span class="lineNum">      88 </span>            :         }
<span class="lineNum">      89 </span>            :         
<span class="lineNum">      90 </span><span class="lineCov">          1 :         int iLexUnitUnknown = m_lexiconManager-&gt;m_lexUnitUnknown-&gt;iLexUnit;</span>
<span class="lineNum">      91 </span><span class="lineCov">          1 :         int iLexUnitBegSentence = m_lexiconManager-&gt;m_lexUnitBegSentence-&gt;iLexUnit;</span>
<span class="lineNum">      92 </span><span class="lineCov">          1 :         int iLexUnitEndSentence = m_lexiconManager-&gt;m_lexUnitEndSentence-&gt;iLexUnit;</span>
<span class="lineNum">      93 </span><span class="lineCov">          1 :         NGram *ngramFinal = lmARPA-&gt;getNGram(&amp;iLexUnitEndSentence,1);</span>
<span class="lineNum">      94 </span><span class="lineCov">          1 :         assert(ngramFinal);</span>
<span class="lineNum">      95 </span>            :         
<span class="lineNum">      96 </span><span class="lineCov">          1 :         LMStateTemp *states = NULL;</span>
<span class="lineNum">      97 </span><span class="lineCov">          1 :         LMStateTemp *stateInitial = NULL;</span>
<span class="lineNum">      98 </span><span class="lineCov">          1 :         LMStateTemp *stateFinal = NULL;</span>
<span class="lineNum">      99 </span>            :         
<span class="lineNum">     100 </span>            :         // zerogram (special case)
<span class="lineNum">     101 </span><span class="lineCov">          1 :         if (m_iNGramOrder == LM_NGRAM_ZEROGRAM) {</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :                 states = new LMStateTemp[1];</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :                 states[0].iState = 0;           </span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :                 m_iStates = 1;</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :                 stateInitial = stateFinal = states;</span>
<span class="lineNum">     106 </span>            :         
<span class="lineNum">     107 </span>            :                 // compacting
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :                 compact(states,m_iStates,m_iArcs,stateInitial,stateFinal);</span>
<span class="lineNum">     109 </span>            :                         
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :                 BVC_VERB &lt;&lt; &quot;-- FSM ------------------------------------&quot;;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :                 BVC_VERB &lt;&lt; &quot; zerogram (uniform distribution)&quot;;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :                 BVC_VERB &lt;&lt; &quot;-------------------------------------------&quot;;</span>
<span class="lineNum">     113 </span>            :                 
<span class="lineNum">     114 </span>            :                 // clean-up
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :                 delete [] states;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :                 delete [] iIgnoredNGrams;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :                 m_bLoaded = true;</span>
<span class="lineNum">     118 </span><span class="lineCov">          1 :                 return;</span>
<span class="lineNum">     119 </span>            :         }
<span class="lineNum">     120 </span>            :         
<span class="lineNum">     121 </span>            :         // allocate memory to store the states (for example, for trigram: backoff + #unigrams + #bigrams)
<span class="lineNum">     122 </span><span class="lineCov">          1 :         int iStatesMax = 1;</span>
<span class="lineNum">     123 </span><span class="lineCov">          4 :         for(int i=0 ; i &lt; m_iNGramOrder ; ++i) {</span>
<span class="lineNum">     124 </span><span class="lineCov">          3 :                 iStatesMax += lmARPA-&gt;getNGrams(i);</span>
<span class="lineNum">     125 </span>            :         }
<span class="lineNum">     126 </span><span class="lineCov">          1 :         states = new LMStateTemp[iStatesMax];</span>
<span class="lineNum">     127 </span><span class="lineCov">    3538580 :         for(int i=0 ; i &lt; iStatesMax ; ++i) {</span>
<span class="lineNum">     128 </span><span class="lineCov">    3538579 :                 states[i].iState = -1;</span>
<span class="lineNum">     129 </span>            :         }
<span class="lineNum">     130 </span>            :         
<span class="lineNum">     131 </span>            :         // create states and arcs
<span class="lineNum">     132 </span><span class="lineCov">          1 :         int iStateID = 0;</span>
<span class="lineNum">     133 </span>            :         
<span class="lineNum">     134 </span>            :         // maps NGram &lt;-&gt; state in the FSM
<span class="lineNum">     135 </span><span class="lineCov">          1 :         MNGramState mNGramState;</span>
<span class="lineNum">     136 </span>            :         
<span class="lineNum">     137 </span><span class="lineCov">          1 :         LMStateTemp *statesPrev = states;               // points to single back-off state</span>
<span class="lineNum">     138 </span><span class="lineCov">          1 :         statesPrev-&gt;iState = iStateID++;                     // zerogram backoff state</span>
<span class="lineNum">     139 </span><span class="lineCov">          1 :         LMStateTemp *stateDest = states+1;              // points to unigram states</span>
<span class="lineNum">     140 </span>            :         
<span class="lineNum">     141 </span><span class="lineCov">          1 :         int iNGramsPrev = -1;   </span>
<span class="lineNum">     142 </span><span class="lineCov">          1 :         NGram *ngramsPrev = lmARPA-&gt;getNGrams(0,&amp;iNGramsPrev);</span>
<span class="lineNum">     143 </span><span class="lineCov">          1 :         mNGramState.insert(MNGramState::value_type(hashKey(ngramsPrev),statesPrev));</span>
<span class="lineNum">     144 </span><span class="lineCov">          3 :         for(int iOrder = 1 ; iOrder &lt;= m_iNGramOrder ; ++iOrder) {</span>
<span class="lineNum">     145 </span>            :                 
<span class="lineNum">     146 </span><span class="lineCov">    3538581 :                 for(int i=0 ; i &lt; iNGramsPrev ; ++i) {               // there is one FSM state for each previous n-gram</span>
<span class="lineNum">     147 </span>            :                 
<span class="lineNum">     148 </span>            :                         // standard arcs
<span class="lineNum">     149 </span>            :                         //LMStateTemp *statePrev = statesPrev+i;
<span class="lineNum">     150 </span><span class="lineCov">    3538578 :                         NGram *prev = ngramsPrev+i;</span>
<span class="lineNum">     151 </span><span class="lineCov">    3538578 :                         assert(prev-&gt;iNGrams &gt;= 0);</span>
<span class="lineNum">     152 </span><span class="lineCov">    3538578 :                         MNGramState::iterator it = mNGramState.find(hashKey(prev));</span>
<span class="lineNum">     153 </span><span class="lineCov">    3538578 :                         if (it == mNGramState.end()) {</span>
<span class="lineNum">     154 </span><span class="lineCov">      51596 :                                 iIgnoredNGrams[iOrder] += prev-&gt;iNGrams;</span>
<span class="lineNum">     155 </span><span class="lineCov">     103193 :                                 continue;</span>
<span class="lineNum">     156 </span>            :                         }
<span class="lineNum">     157 </span><span class="lineCov">    3486982 :                         LMStateTemp *statePrev = it-&gt;second;</span>
<span class="lineNum">     158 </span>            :                         
<span class="lineNum">     159 </span>            :                         // skip unreachable states (also, no transitions from final state)
<span class="lineNum">     160 </span><span class="lineCov">    3486982 :                         assert(statePrev-&gt;iState != -1);</span>
<span class="lineNum">     161 </span><span class="lineCov">    3486982 :                         if (prev-&gt;iLexUnit == iLexUnitEndSentence) {</span>
<span class="lineNum">     162 </span><span class="lineCov">          1 :                                 iIgnoredNGrams[iOrder] += prev-&gt;iNGrams;</span>
<span class="lineNum">     163 </span><span class="lineCov">          1 :                                 stateDest += prev-&gt;iNGrams;</span>
<span class="lineNum">     164 </span><span class="lineCov">          1 :                                 continue;       </span>
<span class="lineNum">     165 </span>            :                         }
<span class="lineNum">     166 </span><span class="lineCov">   10022557 :                         for(int j=0 ; j &lt; prev-&gt;iNGrams ; ++j, ++stateDest) {</span>
<span class="lineNum">     167 </span><span class="lineCov">    6535576 :                                 int iLexUnit = prev-&gt;ngrams[j].iLexUnit;</span>
<span class="lineNum">     168 </span><span class="lineCov">    6535576 :                                 if ((iLexUnit == iLexUnitUnknown) /*|| ((iLexUnit == iLexUnitBegSentence) &amp;&amp; (iOrder &gt; 1))*/) {</span>
<span class="lineNum">     169 </span>            :                                         //lmARPA-&gt;print(&amp;prev-&gt;ngrams[j]);
<span class="lineNum">     170 </span><span class="lineCov">      81247 :                                         ++iIgnoredNGrams[iOrder];</span>
<span class="lineNum">     171 </span><span class="lineCov">      81247 :                                         continue;</span>
<span class="lineNum">     172 </span>            :                                 } 
<span class="lineNum">     173 </span>            :                                 // connect to final state (&lt;/s&gt;)
<span class="lineNum">     174 </span><span class="lineCov">    6454329 :                                 else if ((iLexUnit == iLexUnitEndSentence) &amp;&amp; (iOrder &gt; 1)) {</span>
<span class="lineNum">     175 </span><span class="lineCov">     146091 :                                         MNGramState::iterator it = mNGramState.find(hashKey(ngramFinal));</span>
<span class="lineNum">     176 </span><span class="lineCov">     146091 :                                         assert(it != mNGramState.end());</span>
<span class="lineNum">     177 </span><span class="lineCov">     146091 :                                         statePrev-&gt;lArc.push_back(newArc(iLexUnit,prev-&gt;ngrams[j].fProbability,it-&gt;second));</span>
<span class="lineNum">     178 </span><span class="lineCov">     146091 :                                         continue;</span>
<span class="lineNum">     179 </span>            :                                 }
<span class="lineNum">     180 </span><span class="lineCov">    6308238 :                                 if (iOrder &lt; m_iNGramOrder) {</span>
<span class="lineNum">     181 </span><span class="lineCov">    3486981 :                                         mNGramState.insert(MNGramState::value_type(hashKey(&amp;prev-&gt;ngrams[j]),stateDest));</span>
<span class="lineNum">     182 </span><span class="lineCov">    3486981 :                                         stateDest-&gt;iState = iStateID++;</span>
<span class="lineNum">     183 </span><span class="lineCov">    3486981 :                                         statePrev-&gt;lArc.push_back(newArc(iLexUnit,prev-&gt;ngrams[j].fProbability,stateDest));       </span>
<span class="lineNum">     184 </span>            :                                 } else {
<span class="lineNum">     185 </span>            :                                         //lmARPA-&gt;print(&amp;prev-&gt;ngrams[j]);
<span class="lineNum">     186 </span><span class="lineCov">    2821257 :                                         assert(iOrder == m_iNGramOrder);        </span>
<span class="lineNum">     187 </span><span class="lineCov">    2821257 :                                         MNGramState::iterator it = mNGramState.find(hashKey(prev,true,(m_iNGramOrder &gt; 1) ? iLexUnit : -1)); </span>
<span class="lineNum">     188 </span><span class="lineCov">    2821257 :                                         if (it != mNGramState.end()) {</span>
<span class="lineNum">     189 </span><span class="lineCov">    2821257 :                                                 statePrev-&gt;lArc.push_back(newArc(iLexUnit,prev-&gt;ngrams[j].fProbability,it-&gt;second));</span>
<span class="lineNum">     190 </span>            :                                         } else {
<span class="lineNum">     191 </span>            :                                                 //lmARPA-&gt;print(&amp;prev-&gt;ngrams[j]);    
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :                                                 ++iIgnoredNGrams[iOrder];</span>
<span class="lineNum">     193 </span>            :                                         }
<span class="lineNum">     194 </span>            :                                 }
<span class="lineNum">     195 </span>            :                         }
<span class="lineNum">     196 </span>            :                         // backoff arc
<span class="lineNum">     197 </span><span class="lineCov">    3486981 :                         if (iOrder &gt; 1) {</span>
<span class="lineNum">     198 </span><span class="lineCov">    3486980 :                                 MNGramState::iterator it = mNGramState.find(hashKey(prev,true));        </span>
<span class="lineNum">     199 </span><span class="lineCov">    3486980 :                                 assert(it != mNGramState.end());</span>
<span class="lineNum">     200 </span><span class="lineCov">    3486980 :                                 statePrev-&gt;lArc.push_back(newArc(BACKOFF_ARC,prev-&gt;fProbabilityBackoff,it-&gt;second));</span>
<span class="lineNum">     201 </span>            :                         }
<span class="lineNum">     202 </span>            :                 }       
<span class="lineNum">     203 </span><span class="lineCov">          3 :                 if (iOrder == m_iNGramOrder)</span>
<span class="lineNum">     204 </span><span class="lineCov">          1 :                         break;</span>
<span class="lineNum">     205 </span><span class="lineCov">          2 :                 statesPrev += lmARPA-&gt;getNGrams(iOrder-1);</span>
<span class="lineNum">     206 </span><span class="lineCov">          2 :                 ngramsPrev = lmARPA-&gt;getNGrams(iOrder,&amp;iNGramsPrev);</span>
<span class="lineNum">     207 </span>            :         }
<span class="lineNum">     208 </span>            :         
<span class="lineNum">     209 </span><span class="lineCov">          1 :         m_iArcs = m_iArcsStandard+m_iArcsBackoff;</span>
<span class="lineNum">     210 </span>            :         
<span class="lineNum">     211 </span>            :         // get initial and final states
<span class="lineNum">     212 </span><span class="lineCov">          1 :         if (m_iNGramOrder &lt;= 1) {</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :                 stateInitial = stateFinal = states;</span>
<span class="lineNum">     214 </span>            :         } else {        
<span class="lineNum">     215 </span>            :                 // initial state
<span class="lineNum">     216 </span><span class="lineCov">          1 :                 MNGramState::iterator it;       </span>
<span class="lineNum">     217 </span><span class="lineCov">          1 :                 it = mNGramState.find(hashKey(lmARPA-&gt;getNGram(&amp;iLexUnitBegSentence,1)));        </span>
<span class="lineNum">     218 </span><span class="lineCov">          1 :                 if (it == mNGramState.end()) {</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :                         BVC_ERROR &lt;&lt; &quot;initial state (&lt;s&gt;) not found, make sure there is an unigram for &lt;s&gt;&quot;;</span>
<span class="lineNum">     220 </span>            :                 }
<span class="lineNum">     221 </span><span class="lineCov">          1 :                 stateInitial = it-&gt;second;</span>
<span class="lineNum">     222 </span>            :                 // final state
<span class="lineNum">     223 </span><span class="lineCov">          1 :                 it = mNGramState.find(hashKey(lmARPA-&gt;getNGram(&amp;iLexUnitEndSentence,1)));        </span>
<span class="lineNum">     224 </span><span class="lineCov">          1 :                 if (it == mNGramState.end()) {</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :                         BVC_ERROR &lt;&lt; &quot;final state (&lt;/s&gt;) not found, make sure there is an unigram for &lt;s&gt;&quot;;</span>
<span class="lineNum">     226 </span>            :                 }
<span class="lineNum">     227 </span><span class="lineCov">          1 :                 stateFinal = it-&gt;second;</span>
<span class="lineNum">     228 </span>            :         }
<span class="lineNum">     229 </span>            :         
<span class="lineNum">     230 </span><span class="lineCov">          1 :         m_iStates = iStatesMax;</span>
<span class="lineNum">     231 </span>            :         
<span class="lineNum">     232 </span><span class="lineCov">          1 :         double dTimeEndBuilding = TimeUtils::getTimeMilliseconds();</span>
<span class="lineNum">     233 </span>            :         
<span class="lineNum">     234 </span>            :         // sanity check
<span class="lineNum">     235 </span><span class="lineCov">          1 :         checkConnected(stateInitial,stateFinal,states,iStateID,m_iArcs);</span>
<span class="lineNum">     236 </span>            :         
<span class="lineNum">     237 </span><span class="lineCov">          1 :         double dTimeEndChecks = TimeUtils::getTimeMilliseconds();</span>
<span class="lineNum">     238 </span>            :         
<span class="lineNum">     239 </span>            :         // compacting
<span class="lineNum">     240 </span><span class="lineCov">          1 :         compact(states,m_iStates,m_iArcs,stateInitial,stateFinal);</span>
<span class="lineNum">     241 </span>            :         
<span class="lineNum">     242 </span><span class="lineCov">          1 :         double dTimeEndCompacting = TimeUtils::getTimeMilliseconds();</span>
<span class="lineNum">     243 </span>            :         
<span class="lineNum">     244 </span>            :         // print summary
<span class="lineNum">     245 </span><span class="lineCov">          1 :         BVC_VERB &lt;&lt; &quot;-- FSM ------------------------------------&quot;;</span>
<span class="lineNum">     246 </span><span class="lineCov">          1 :         BVC_VERB &lt;&lt; &quot; # states: &quot; &lt;&lt; iStateID;</span>
<span class="lineNum">     247 </span><span class="lineCov">          1 :         BVC_VERB &lt;&lt; &quot; # arcs: &quot; &lt;&lt; m_iArcs &lt;&lt; &quot; (standard: &quot; &lt;&lt; m_iArcsStandard &lt;&lt; &quot;, backoff: &quot; &lt;&lt; m_iArcsBackoff &lt;&lt; &quot;)&quot;;</span>
<span class="lineNum">     248 </span><span class="lineCov">          5 :         for(int i=0 ; i &lt;= m_iNGramOrder ; ++i) {</span>
<span class="lineNum">     249 </span><span class="lineCov">          4 :                 if (iIgnoredNGrams[i] &gt; 0) {</span>
<span class="lineNum">     250 </span><span class="lineCov">          3 :                         BVC_VERB &lt;&lt; &quot; # ignored &quot; &lt;&lt; LMManager::getStrNGram(i) &lt;&lt; &quot;s: &quot; &lt;&lt; iIgnoredNGrams[i];</span>
<span class="lineNum">     251 </span>            :                 }
<span class="lineNum">     252 </span>            :         }
<span class="lineNum">     253 </span><span class="lineCov">          1 :         int iBytes = (m_iStates*sizeof(LMState)+m_iArcs*sizeof(LMArc));</span>
<span class="lineNum">     254 </span><span class="lineCov">          1 :         BVC_VERB &lt;&lt; &quot; size: &quot; &lt;&lt; iBytes &lt;&lt; &quot; bytes (&quot; &lt;&lt; ((float)iBytes)/(1024.0*1024.0) &lt;&lt; &quot; MBs)&quot;;</span>
<span class="lineNum">     255 </span><span class="lineCov">          1 :         BVC_VERB &lt;&lt; &quot; building time:   &quot; &lt;&lt; (dTimeEndBuilding-dTimeBegin)/1000.0 &lt;&lt; &quot; seconds&quot;;</span>
<span class="lineNum">     256 </span><span class="lineCov">          1 :         BVC_VERB &lt;&lt; &quot; check time:      &quot; &lt;&lt; (dTimeEndChecks-dTimeEndBuilding)/1000.0 &lt;&lt; &quot; seconds&quot;;</span>
<span class="lineNum">     257 </span><span class="lineCov">          1 :         BVC_VERB &lt;&lt; &quot; compacting time: &quot; &lt;&lt; (dTimeEndCompacting-dTimeEndChecks)/1000.0 &lt;&lt; &quot; seconds&quot;;</span>
<span class="lineNum">     258 </span><span class="lineCov">          1 :         BVC_VERB &lt;&lt; &quot; total time: &quot; &lt;&lt; (dTimeEndCompacting-dTimeBegin)/1000.0 &lt;&lt; &quot; seconds&quot;;</span>
<span class="lineNum">     259 </span><span class="lineCov">          1 :         BVC_VERB &lt;&lt; &quot;-------------------------------------------&quot;;</span>
<span class="lineNum">     260 </span>            :         
<span class="lineNum">     261 </span>            :         // clean-up
<span class="lineNum">     262 </span><span class="lineCov">    3538580 :         for(int i=0 ; i&lt;iStatesMax ; ++i) {</span>
<span class="lineNum">     263 </span><span class="lineCov">   13479888 :                 for(LLMArcTemp::iterator it = states[i].lArc.begin() ; it != states[i].lArc.end() ; ++it) {</span>
<span class="lineNum">     264 </span><span class="lineCov">    9941309 :                         delete *it;</span>
<span class="lineNum">     265 </span>            :                 }
<span class="lineNum">     266 </span>            :         }       
<span class="lineNum">     267 </span><span class="lineCov">          1 :         delete [] states;               </span>
<span class="lineNum">     268 </span><span class="lineCov">          1 :         delete [] iIgnoredNGrams;</span>
<span class="lineNum">     269 </span>            :         
<span class="lineNum">     270 </span><span class="lineCov">          1 :         m_bLoaded = true;</span>
<span class="lineNum">     271 </span>            : }
<a name="272"><span class="lineNum">     272 </span>            : </a>
<span class="lineNum">     273 </span>            : // perform sanity checks to make sure that all the states/arcs created are connected
<span class="lineNum">     274 </span><span class="lineCov">          1 : void LMFSM::checkConnected(LMStateTemp *stateInitial, LMStateTemp *stateFinal, </span>
<span class="lineNum">     275 </span>            :         LMStateTemp *stateBackoffZerogram, int iStates, int iArcs) {
<span class="lineNum">     276 </span>            :         
<span class="lineNum">     277 </span><span class="lineCov">          1 :         bool *bStateProcessed = new bool[iStates];</span>
<span class="lineNum">     278 </span><span class="lineCov">    3486983 :         for(int i=0 ; i&lt;iStates ; ++i) {</span>
<span class="lineNum">     279 </span><span class="lineCov">    3486982 :                 bStateProcessed[i] = false;</span>
<span class="lineNum">     280 </span>            :         }
<span class="lineNum">     281 </span><span class="lineCov">          1 :         int iStatesSeen = 0;</span>
<span class="lineNum">     282 </span><span class="lineCov">          1 :         int iArcsSeen = 0;</span>
<span class="lineNum">     283 </span><span class="lineCov">          1 :         LLMStateTemp lState;</span>
<span class="lineNum">     284 </span><span class="lineCov">          1 :         lState.push_back(stateInitial);</span>
<span class="lineNum">     285 </span><span class="lineCov">          1 :         bStateProcessed[stateInitial-&gt;iState] = true;</span>
<span class="lineNum">     286 </span><span class="lineCov">    3486984 :         while(lState.empty() == false) {</span>
<span class="lineNum">     287 </span>            :                 
<span class="lineNum">     288 </span>            :                 // get the next state to process
<span class="lineNum">     289 </span><span class="lineCov">    3486982 :                 LMStateTemp *stateFrom = lState.front();</span>
<span class="lineNum">     290 </span><span class="lineCov">    3486982 :                 lState.pop_front();</span>
<span class="lineNum">     291 </span>            :                 
<span class="lineNum">     292 </span><span class="lineCov">    3486982 :                 bool bBackoff = false;</span>
<span class="lineNum">     293 </span><span class="lineCov">   13428291 :                 for(LLMArcTemp::iterator it = stateFrom-&gt;lArc.begin() ; it != stateFrom-&gt;lArc.end() ; ++it) {</span>
<span class="lineNum">     294 </span>            :                 
<span class="lineNum">     295 </span><span class="lineCov">    9941309 :                         if ((*it)-&gt;iLexUnit == BACKOFF_ARC) { bBackoff = true; }</span>
<span class="lineNum">     296 </span>            :                 
<span class="lineNum">     297 </span>            :                         // insert G destination states into the queue (if not already processed)
<span class="lineNum">     298 </span><span class="lineCov">    9941309 :                         if (bStateProcessed[(*it)-&gt;stateDest-&gt;iState] == false) {</span>
<span class="lineNum">     299 </span><span class="lineCov">    3486981 :                                 lState.push_back((*it)-&gt;stateDest);</span>
<span class="lineNum">     300 </span><span class="lineCov">    3486981 :                                 bStateProcessed[(*it)-&gt;stateDest-&gt;iState] = true;</span>
<span class="lineNum">     301 </span>            :                         }
<span class="lineNum">     302 </span>            :                         // make sure the transition has a valid symbol
<span class="lineNum">     303 </span><span class="lineCov">    9941309 :                         if ((*it)-&gt;iLexUnit != BACKOFF_ARC) {</span>
<span class="lineNum">     304 </span>            :                         
<span class="lineNum">     305 </span><span class="lineCov">   13054752 :                                 if (!m_lexiconManager-&gt;isStandard((*it)-&gt;iLexUnit) &amp;&amp; </span>
<span class="lineNum">     306 </span><span class="lineCov">    6454332 :                                         ((*it)-&gt;iLexUnit != m_lexiconManager-&gt;m_lexUnitEndSentence-&gt;iLexUnit) &amp;&amp;</span>
<span class="lineNum">     307 </span><span class="lineCov">          1 :                                         ((stateFrom != stateBackoffZerogram) || ((*it)-&gt;stateDest != stateInitial) || ((*it)-&gt;iLexUnit != m_lexiconManager-&gt;m_lexUnitBegSentence-&gt;iLexUnit))) {</span>
<span class="lineNum">     308 </span><span class="lineCov">          1 :                                         BVC_WARNING &lt;&lt; &quot;unexpected lexical unit: &quot; &lt;&lt; m_lexiconManager-&gt;getStrLexUnit((*it)-&gt;iLexUnit) &lt;&lt; &quot; !!&quot;;</span>
<span class="lineNum">     309 </span>            :                                 }
<span class="lineNum">     310 </span>            :                         }
<span class="lineNum">     311 </span>            :                         
<span class="lineNum">     312 </span><span class="lineCov">    9941309 :                         ++iArcsSeen;</span>
<span class="lineNum">     313 </span>            :                 }
<span class="lineNum">     314 </span><span class="lineCov">    3486982 :                 if ((bBackoff == false) &amp;&amp; (stateFrom != stateFinal) &amp;&amp; (stateFrom != stateBackoffZerogram)) {</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :                         BVC_ERROR &lt;&lt; &quot;backoff-arc expected but not found, lm is not well formed&quot;;</span>
<span class="lineNum">     316 </span>            :                 }
<span class="lineNum">     317 </span>            :                 
<span class="lineNum">     318 </span><span class="lineCov">    3486982 :                 ++iStatesSeen;  </span>
<span class="lineNum">     319 </span>            :         }
<span class="lineNum">     320 </span><span class="lineCov">    3486983 :         for(int i=0 ; i&lt;iStates ; ++i) {</span>
<span class="lineNum">     321 </span><span class="lineCov">    3486982 :                 if (bStateProcessed[i] == false) {</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :                         BVC_WARNING &lt;&lt; &quot;lm-state not seen: &quot; &lt;&lt; i;</span>
<span class="lineNum">     323 </span>            :                 }
<span class="lineNum">     324 </span>            :         }       
<span class="lineNum">     325 </span><span class="lineCov">          1 :         assert(iStatesSeen == iStates);</span>
<span class="lineNum">     326 </span><span class="lineCov">          1 :         assert(iArcsSeen == iArcs);</span>
<span class="lineNum">     327 </span><span class="lineCov">          1 :         delete [] bStateProcessed;      </span>
<span class="lineNum">     328 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     329 </span>            : 
<a name="330"><span class="lineNum">     330 </span>            : // compact the FSM to use less memory and speed-up lookups (better locality)</a>
<span class="lineNum">     331 </span>            : // note: most of the cpu time goes to sorting arcs by lexical unit
<span class="lineNum">     332 </span><span class="lineCov">          1 : void LMFSM::compact(LMStateTemp *states, int iStates, int iArcs, LMStateTemp *stateInitial, LMStateTemp *stateFinal) {</span>
<span class="lineNum">     333 </span>            :         
<span class="lineNum">     334 </span>            :         // allocate memory
<span class="lineNum">     335 </span><span class="lineCov">          1 :         m_iStates = iStates;</span>
<span class="lineNum">     336 </span><span class="lineCov">          1 :         m_iArcs = iArcs;</span>
<span class="lineNum">     337 </span><span class="lineCov">          1 :         m_states = new LMState[m_iStates+1];            // extra state is needed to mark the ending arc</span>
<span class="lineNum">     338 </span><span class="lineCov">          1 :         m_arcs = new LMArc[m_iArcs];</span>
<span class="lineNum">     339 </span>            :         
<span class="lineNum">     340 </span>            :         // keep already created nodes (indexed by the corresponding temporal node id)
<span class="lineNum">     341 </span><span class="lineCov">          1 :         int *iStateCreated = new int[m_iStates];</span>
<span class="lineNum">     342 </span><span class="lineCov">          1 :         int *iFirstArc = new int[m_iStates];</span>
<span class="lineNum">     343 </span><span class="lineCov">    3538580 :         for(int i=0 ; i&lt;m_iStates ; ++i) {</span>
<span class="lineNum">     344 </span><span class="lineCov">    3538579 :                 iStateCreated[i] = iFirstArc[i] = -1;</span>
<span class="lineNum">     345 </span>            :         }
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :         // fill the structures
<span class="lineNum">     348 </span><span class="lineCov">          1 :         int iState = 0;</span>
<span class="lineNum">     349 </span><span class="lineCov">          1 :         int iArc = 0;</span>
<span class="lineNum">     350 </span><span class="lineCov">          1 :         int iStateActual = 0;</span>
<span class="lineNum">     351 </span><span class="lineCov">    3538580 :         for(int iStateTemp = 0 ; iStateTemp &lt; m_iStates ; ++iStateTemp) {</span>
<span class="lineNum">     352 </span>            :         
<span class="lineNum">     353 </span><span class="lineCov">    3538579 :                 if (states[iStateTemp].iState == -1) {</span>
<span class="lineNum">     354 </span><span class="lineCov">      51597 :                         continue;</span>
<span class="lineNum">     355 </span>            :                 }       
<span class="lineNum">     356 </span>            :         
<span class="lineNum">     357 </span>            :                 // sort arcs by lexical unit so we can use a binary search for arc lookups
<span class="lineNum">     358 </span><span class="lineCov">    3486982 :                 states[iStateTemp].lArc.sort(LMFSM::compareArcs);</span>
<span class="lineNum">     359 </span>            :         
<span class="lineNum">     360 </span>            :                 LMState *stateAux;
<span class="lineNum">     361 </span><span class="lineCov">    3486982 :                 int iArcBase = -1;</span>
<span class="lineNum">     362 </span><span class="lineCov">    3486982 :                 if (iStateCreated[iStateActual] == -1) {</span>
<span class="lineNum">     363 </span><span class="lineCov">          1 :                         stateAux = &amp;m_states[iState];</span>
<span class="lineNum">     364 </span><span class="lineCov">          1 :                         iStateCreated[iStateActual] = iState++;</span>
<span class="lineNum">     365 </span><span class="lineCov">          1 :                         iArcBase = iArc;</span>
<span class="lineNum">     366 </span><span class="lineCov">          1 :                         iArc += (int)states[iStateTemp].lArc.size();</span>
<span class="lineNum">     367 </span>            :                 } else {                
<span class="lineNum">     368 </span><span class="lineCov">    3486981 :                         stateAux = &amp;m_states[iStateCreated[iStateActual]]; </span>
<span class="lineNum">     369 </span><span class="lineCov">    3486981 :                         iArcBase = iFirstArc[iStateCreated[iStateActual]];</span>
<span class="lineNum">     370 </span>            :                 }
<span class="lineNum">     371 </span><span class="lineCov">    3486982 :                 stateAux-&gt;iArcBase = iArcBase;</span>
<span class="lineNum">     372 </span>            :                 // store the outgoing arcs
<span class="lineNum">     373 </span><span class="lineCov">    3486982 :                 int j=0;</span>
<span class="lineNum">     374 </span><span class="lineCov">   13428291 :                 for(LLMArcTemp::iterator jt = states[iStateTemp].lArc.begin() ; jt != states[iStateTemp].lArc.end() ; ++jt,++j) {</span>
<span class="lineNum">     375 </span><span class="lineCov">    9941309 :                         if (iStateCreated[(*jt)-&gt;stateDest-&gt;iState] == -1) {</span>
<span class="lineNum">     376 </span><span class="lineCov">    3486981 :                                 iStateCreated[(*jt)-&gt;stateDest-&gt;iState] = iState;</span>
<span class="lineNum">     377 </span><span class="lineCov">    3486981 :                                 iFirstArc[iState] = iArc;</span>
<span class="lineNum">     378 </span><span class="lineCov">    3486981 :                                 iArc += (int)(*jt)-&gt;stateDest-&gt;lArc.size();</span>
<span class="lineNum">     379 </span><span class="lineCov">    3486981 :                                 iState++;</span>
<span class="lineNum">     380 </span>            :                         }
<span class="lineNum">     381 </span><span class="lineCov">    9941309 :                         m_arcs[iArcBase+j].iLexUnit = (*jt)-&gt;iLexUnit;</span>
<span class="lineNum">     382 </span><span class="lineCov">    9941309 :                         m_arcs[iArcBase+j].fScore = (*jt)-&gt;fScore;</span>
<span class="lineNum">     383 </span><span class="lineCov">    9941309 :                         m_arcs[iArcBase+j].iStateDest = iStateCreated[(*jt)-&gt;stateDest-&gt;iState];</span>
<span class="lineNum">     384 </span>            :                 }
<span class="lineNum">     385 </span><span class="lineCov">    3486982 :                 ++iStateActual;</span>
<span class="lineNum">     386 </span>            :         }
<span class="lineNum">     387 </span>            :         
<span class="lineNum">     388 </span><span class="lineCov">          1 :         m_iStates = iStateActual;</span>
<span class="lineNum">     389 </span>            :                 
<span class="lineNum">     390 </span><span class="lineCov">          1 :         assert(iArc == m_iArcs);</span>
<span class="lineNum">     391 </span><span class="lineCov">          1 :         assert(iState == m_iStates);</span>
<span class="lineNum">     392 </span><span class="lineCov">          1 :         m_states[m_iStates].iArcBase = m_iArcs;</span>
<span class="lineNum">     393 </span>            :         
<span class="lineNum">     394 </span><span class="lineCov">          1 :         m_iLMStateInitial = iStateCreated[stateInitial-&gt;iState];</span>
<span class="lineNum">     395 </span><span class="lineCov">          1 :         m_iLMStateFinal = iStateCreated[stateFinal-&gt;iState]; </span>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :         // sanity check
<span class="lineNum">     398 </span><span class="lineCov">    3486983 :         for(int i = 0 ; i &lt; m_iStates ; ++i) {       </span>
<span class="lineNum">     399 </span><span class="lineCov">    3486982 :                 if (states[i].iState == -1) {</span>
<span class="lineNum">     400 </span><span class="lineCov">      34195 :                         continue;</span>
<span class="lineNum">     401 </span>            :                 }       
<span class="lineNum">     402 </span><span class="lineCov">    3452787 :                 assert(m_states[i].iArcBase &lt;= m_states[i+1].iArcBase);</span>
<span class="lineNum">     403 </span>            :         }       
<span class="lineNum">     404 </span>            :         
<span class="lineNum">     405 </span><span class="lineCov">          1 :         delete [] iStateCreated;</span>
<span class="lineNum">     406 </span><span class="lineCov">          1 :         delete [] iFirstArc;</span>
<span class="lineNum">     407 </span><span class="lineCov">          1 : }</span>
<a name="408"><span class="lineNum">     408 </span>            : </a>
<span class="lineNum">     409 </span>            : // store to disk
<span class="lineNum">     410 </span><span class="lineNoCov">          0 : void LMFSM::store(const char *strFile) {</span>
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         assert(m_bLoaded == true);</span>
<span class="lineNum">     413 </span>            :         
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         double dTimeBegin = TimeUtils::getTimeMilliseconds();</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :         FileOutput file(strFile,true);</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :         file.open();</span>
<span class="lineNum">     418 </span>            :         
<span class="lineNum">     419 </span>            :         // store the actual FSM 
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         IOBase::write(file.getStream(),m_iStates);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :         IOBase::write(file.getStream(),m_iArcs);</span>
<span class="lineNum">     422 </span>            :         
<span class="lineNum">     423 </span>            :         // store the transitions along with the state information
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :         for(int i = 0 ; i &lt; m_iStates ; ++i) {</span>
<span class="lineNum">     425 </span>            :                 // # of arcs
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :                 int iArcs = m_states[i+1].iArcBase-m_states[i].iArcBase;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :                 assert((iArcs &gt; 0) || (i == m_iLMStateFinal));</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :                 IOBase::write(file.getStream(),iArcs);</span>
<span class="lineNum">     429 </span>            :                 // actual arcs
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :                 for(LMArc *arc = m_arcs+m_states[i].iArcBase ; arc != m_arcs+m_states[i+1].iArcBase ; ++arc) {  </span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                         IOBase::write(file.getStream(),arc-&gt;iLexUnit);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :                         IOBase::write(file.getStream(),arc-&gt;fScore);</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :                         IOBase::write(file.getStream(),arc-&gt;iStateDest);</span>
<span class="lineNum">     434 </span>            :                 }
<span class="lineNum">     435 </span>            :         }
<span class="lineNum">     436 </span>            :         
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :         file.close();</span>
<span class="lineNum">     438 </span>            :         
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :         double dTimeEnd = TimeUtils::getTimeMilliseconds();</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :         BVC_VERB &lt;&lt; &quot;language model FSM store time: &quot; &lt;&lt; (dTimeEnd-dTimeBegin)/1000 &lt;&lt; &quot; seconds&quot;;        </span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 : }</span>
<a name="442"><span class="lineNum">     442 </span>            : </a>
<span class="lineNum">     443 </span>            : // load from disk
<span class="lineNum">     444 </span><span class="lineNoCov">          0 : void LMFSM::load(const char *strFile) {</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :         assert(m_bLoaded == false);</span>
<span class="lineNum">     447 </span>            :         
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         double dTimeBegin = TimeUtils::getTimeMilliseconds();</span>
<span class="lineNum">     449 </span>            :         
<span class="lineNum">     450 </span>            :         // open the file for reading
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         FileInput file(strFile,true);</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :         file.open();</span>
<span class="lineNum">     453 </span>            :         
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         IOBase::read(file.getStream(),&amp;m_iStates);</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :         IOBase::read(file.getStream(),&amp;m_iArcs);</span>
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            :         // minimum is 1 state and zero arcs (zerogram)
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         if ((m_iStates &lt;= 0) || (m_iArcs &lt; 0)) {</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                 BVC_ERROR &lt;&lt; &quot;wrong number of states/arcs: states = &quot; &lt;&lt; m_iStates &lt;&lt; &quot;, arcs = &quot; &lt;&lt; m_iArcs;       </span>
<span class="lineNum">     460 </span>            :         }
<span class="lineNum">     461 </span>            :         
<span class="lineNum">     462 </span>            :         // allocate memory for the states and arcs
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :         m_states = new LMState[m_iStates+1];</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         m_arcs = new LMArc[m_iArcs];</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :         m_states-&gt;iArcBase = 0;</span>
<span class="lineNum">     466 </span>            :         
<span class="lineNum">     467 </span>            :         // load the transitions along with the state information
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :         unsigned int iArcOffset = 0;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         for(int i = 0 ; i &lt; m_iStates ; ++i) {</span>
<span class="lineNum">     470 </span>            :                 // # of arcs
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                 unsigned int iArcs = 0;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                 IOBase::read(file.getStream(),&amp;iArcs);      </span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :                 if (iArcs == 0) {</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                         m_iLMStateFinal = i;</span>
<span class="lineNum">     475 </span>            :                 }
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                 m_states[i+1].iArcBase = iArcOffset+iArcs;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :                 for(unsigned int j = 0 ; j &lt; iArcs ; ++j) {</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :                         IOBase::read(file.getStream(),&amp;m_arcs[iArcOffset].iLexUnit);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :                         IOBase::read(file.getStream(),&amp;m_arcs[iArcOffset].fScore);</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                         IOBase::read(file.getStream(),&amp;m_arcs[iArcOffset].iStateDest);</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :                         int iStateDest = m_arcs[iArcOffset].iStateDest;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :                         assert((iStateDest &gt;= 0) &amp;&amp; (iStateDest &lt; m_iStates));</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :                         ++iArcOffset;   </span>
<span class="lineNum">     484 </span>            :                 }
<span class="lineNum">     485 </span>            :         }
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :         m_states[m_iStates].iArcBase = m_iArcs;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         m_iLMStateInitial = 0;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         assert(m_iLMStateFinal != -1);</span>
<span class="lineNum">     489 </span>            :         
<span class="lineNum">     490 </span>            :         // sanity check
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         for(int i=0 ; i&lt;m_iStates ; ++i) {</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :                 assert((m_states[i].iArcBase &lt; m_states[i+1].iArcBase) || (i == m_iLMStateFinal));</span>
<span class="lineNum">     493 </span>            :         }
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :         // close the file
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :         file.close();</span>
<span class="lineNum">     497 </span>            :         
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :         double dTimeEnd = TimeUtils::getTimeMilliseconds();</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :         BVC_VERB &lt;&lt; &quot;language model FSM loading time: &quot; &lt;&lt; (dTimeEnd-dTimeBegin)/1000 &lt;&lt; &quot; seconds&quot;;      </span>
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :         m_bLoaded = true;</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 : }</span>
<a name="503"><span class="lineNum">     503 </span>            : </a>
<span class="lineNum">     504 </span>            : // get the initial state
<span class="lineNum">     505 </span><span class="lineCov">          2 : int LMFSM::getInitialState() {</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineCov">          2 :         return m_iLMStateInitial;</span>
<span class="lineNum">     508 </span>            : }
<a name="509"><span class="lineNum">     509 </span>            : </a>
<span class="lineNum">     510 </span>            : // update the language model state with the given lexical unit and return the new lm state
<span class="lineNum">     511 </span><span class="lineCov">    4947022 : int LMFSM::updateLMState(int iLMStatePrev, int iLexUnit, float *fScore) {</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            :         // zerogram (uniform distribution), only one state
<span class="lineNum">     514 </span><span class="lineCov">    4947022 :         if (m_iNGramOrder == LM_NGRAM_ZEROGRAM) {</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :                 *fScore = log10f(1.0/((float)m_lexiconManager-&gt;getVocabularySize()));</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :                 return m_iLMStateInitial;</span>
<span class="lineNum">     517 </span>            :         }       
<span class="lineNum">     518 </span>            :         // higher order n-grams
<span class="lineNum">     519 </span>            :         else {
<span class="lineNum">     520 </span><span class="lineCov">    4947022 :                 assert(m_iNGramOrder &gt;= LM_NGRAM_UNIGRAM);   </span>
<span class="lineNum">     521 </span><span class="lineCov">    4947022 :                 assert((iLMStatePrev &gt;= 0) &amp;&amp; (iLMStatePrev &lt; m_iStates));</span>
<span class="lineNum">     522 </span><span class="lineCov">    4947022 :                 LMState *state = &amp;m_states[iLMStatePrev];</span>
<span class="lineNum">     523 </span><span class="lineCov">    4947022 :                 *fScore = 0.0;</span>
<span class="lineNum">     524 </span><span class="lineCov">    4947022 :                 int iPasses = 0;</span>
<span class="lineNum">     525 </span>            :                 
<span class="lineNum">     526 </span>            :                 while(1) {
<span class="lineNum">     527 </span>            :                 
<span class="lineNum">     528 </span><span class="lineCov">   10315758 :                         int iFirst = state-&gt;iArcBase;</span>
<span class="lineNum">     529 </span><span class="lineCov">   10315758 :                         int iLast = (state+1)-&gt;iArcBase-1;</span>
<span class="lineNum">     530 </span>            :                         int iMiddle;
<span class="lineNum">     531 </span><span class="lineCov">  120348718 :                         while(iFirst &lt;= iLast) {</span>
<span class="lineNum">     532 </span><span class="lineCov">  104664224 :                                 iMiddle = (iFirst+iLast)/2;</span>
<span class="lineNum">     533 </span><span class="lineCov">  104664224 :                                 if (m_arcs[iMiddle].iLexUnit == iLexUnit) {</span>
<span class="lineNum">     534 </span>            :                                         //cout &lt;&lt; m_lexiconManager-&gt;getStrLexUnit(iLexUnit) &lt;&lt; &quot;: &quot; &lt;&lt; m_arcs[iMiddle].fScore &lt;&lt; endl;
<span class="lineNum">     535 </span><span class="lineCov">    4947022 :                                         *fScore += m_arcs[iMiddle].fScore;</span>
<span class="lineNum">     536 </span><span class="lineCov">    4947022 :                                         return m_arcs[iMiddle].iStateDest;</span>
<span class="lineNum">     537 </span><span class="lineCov">   99717202 :                                 } else if (m_arcs[iMiddle].iLexUnit &lt; iLexUnit) {</span>
<span class="lineNum">     538 </span><span class="lineCov">   50118936 :                                         iFirst = iMiddle+1;</span>
<span class="lineNum">     539 </span>            :                                 } else {
<span class="lineNum">     540 </span><span class="lineCov">   49598266 :                                         iLast = iMiddle-1;</span>
<span class="lineNum">     541 </span>            :                                 }
<span class="lineNum">     542 </span>            :                         }       
<span class="lineNum">     543 </span>            :                         
<span class="lineNum">     544 </span><span class="lineCov">    5368736 :                         LMArc *arcBackoff = &amp;m_arcs[(state+1)-&gt;iArcBase-1];</span>
<span class="lineNum">     545 </span><span class="lineCov">    5368736 :                         assert(arcBackoff-&gt;iLexUnit == BACKOFF_ARC);</span>
<span class="lineNum">     546 </span><span class="lineCov">    5368736 :                         *fScore += arcBackoff-&gt;fScore;</span>
<span class="lineNum">     547 </span><span class="lineCov">    5368736 :                         state = &amp;m_states[arcBackoff-&gt;iStateDest];</span>
<span class="lineNum">     548 </span>            :                         //cout &lt;&lt; &quot;backoff: &quot; &lt;&lt; arcBackoff-&gt;fScore &lt;&lt; endl;
<span class="lineNum">     549 </span>            :                                 
<span class="lineNum">     550 </span><span class="lineCov">    5368736 :                         ++iPasses;</span>
<span class="lineNum">     551 </span><span class="lineCov">    5368736 :                 }</span>
<span class="lineNum">     552 </span>            :         }
<span class="lineNum">     553 </span>            : }
<a name="554"><span class="lineNum">     554 </span>            : </a>
<span class="lineNum">     555 </span>            : // return the score resulting from moving to the given lm-state to the final state
<span class="lineNum">     556 </span><span class="lineCov">       2156 : float LMFSM::toFinalState(int iLMState) {</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :         // zerogram (uniform distribution)
<span class="lineNum">     559 </span><span class="lineCov">       2156 :         if (m_iNGramOrder == LM_NGRAM_ZEROGRAM) {</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :                 return log10f(1.0/((float)m_lexiconManager-&gt;getVocabularySize()));</span>
<span class="lineNum">     561 </span>            :         } 
<span class="lineNum">     562 </span>            :         // higher order n-grams
<span class="lineNum">     563 </span>            :         else {
<span class="lineNum">     564 </span><span class="lineCov">       2156 :                 assert(m_iNGramOrder &gt;= LM_NGRAM_UNIGRAM);</span>
<span class="lineNum">     565 </span><span class="lineCov">       2156 :                 float fScore = -FLT_MAX;</span>
<span class="lineNum">     566 </span><span class="lineCov">       2156 :                 int iLMStateAux = updateLMState(iLMState,m_lexiconManager-&gt;m_lexUnitEndSentence-&gt;iLexUnit,&amp;fScore);</span>
<span class="lineNum">     567 </span><span class="lineCov">       2156 :                 assert(iLMStateAux == m_iLMStateFinal);</span>
<span class="lineNum">     568 </span><span class="lineCov">       2156 :                 return fScore;</span>
<span class="lineNum">     569 </span>            :         } 
<span class="lineNum">     570 </span>            : }
<a name="571"><span class="lineNum">     571 </span>            : </a>
<span class="lineNum">     572 </span>            : // return language model scores for all words in the vocabulary for a given LM-state (word history)
<span class="lineNum">     573 </span><span class="lineNoCov">          0 : void LMFSM::getLMScores(int iLMState, float *fLMScores, int iVocabularySize) {</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :         double dTimeBegin = TimeUtils::getTimeMilliseconds();</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :         LMArc **lmArcBackoff = new LMArc*[m_iNGramOrder-1];</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :         int iEmpty = m_iNGramOrder-2;</span>
<span class="lineNum">     579 </span>            :         
<span class="lineNum">     580 </span>            :         // get the lm-state for each n-gram order (includes actual lm-state plus backoff lm-states)
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :         LMState *state = m_states+iLMState;</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         LMArc *arcBackoff = m_arcs+((state+1)-&gt;iArcBase-1);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         while(arcBackoff-&gt;iLexUnit == BACKOFF_ARC) {</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :                 assert(iEmpty &gt;= 0);</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :                 lmArcBackoff[iEmpty--] = arcBackoff;</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :                 arcBackoff = m_arcs+(((m_states+arcBackoff-&gt;iStateDest)+1)-&gt;iArcBase-1);</span>
<span class="lineNum">     587 </span>            :         }
<span class="lineNum">     588 </span>            :         
<span class="lineNum">     589 </span>            :         // initialization (debug purposes)
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :         for(int i=0 ; i &lt; iVocabularySize; ++i) {</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :                 fLMScores[i] = FLT_MAX;</span>
<span class="lineNum">     592 </span>            :         }
<span class="lineNum">     593 </span>            :         
<span class="lineNum">     594 </span>            :         // (1) unobserved n-grams (backoffs)
<span class="lineNum">     595 </span>            :         // deal with back-off transitions in ascending order (starting from unigrams, then bigrams, etc)
<span class="lineNum">     596 </span>            :         // if a higher-order n-gram exists then its score overwrites the score of lower n-gram backoff
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :         int iComputed = 0;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :         for(int i=iEmpty+1 ; i &lt; m_iNGramOrder-1 ; ++i) {</span>
<span class="lineNum">     599 </span>            :         
<span class="lineNum">     600 </span>            :                 // get accumulated backoff score from higher order n-grams
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :                 float fBackoffAcc = 0.0;</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :                 for(int j=i ; j &lt; m_iNGramOrder-1 ; ++j) {</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :                         fBackoffAcc += lmArcBackoff[j]-&gt;fScore;</span>
<span class="lineNum">     604 </span>            :                 }
<span class="lineNum">     605 </span>            :                 // compute lm-scores for all observed n-grams in this n-gram table
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :                 LMState *state = m_states+lmArcBackoff[i]-&gt;iStateDest;</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :                 LMArc *arcFinal = m_arcs+(state+1)-&gt;iArcBase;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :                 if (i != iEmpty+1) {            // backoff arc is the last arc, stop before it</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :                         arcFinal--;</span>
<span class="lineNum">     610 </span>            :                 }
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :                 for(LMArc *arc = m_arcs+state-&gt;iArcBase; arc != arcFinal ; ++arc) {</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :                         assert((arc-&gt;iLexUnit &gt;= 0) &amp;&amp; (arc-&gt;iLexUnit &lt; iVocabularySize));</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :                         fLMScores[arc-&gt;iLexUnit] = fBackoffAcc+arc-&gt;fScore;       </span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :                         ++iComputed;</span>
<span class="lineNum">     615 </span>            :                 }
<span class="lineNum">     616 </span>            :                 //printf(&quot;computed: %d\n&quot;,iComputed);
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                 iComputed = 0;</span>
<span class="lineNum">     618 </span>            :         }
<span class="lineNum">     619 </span>            :         // (2) observed n-grams
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         assert((m_arcs+((state+1)-&gt;iArcBase)-1)-&gt;iLexUnit == BACKOFF_ARC);</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :         for(LMArc *arc = m_arcs+state-&gt;iArcBase ; arc != m_arcs+((state+1)-&gt;iArcBase)-1 ; ++arc) {</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :                 assert((arc-&gt;iLexUnit &gt;= 0) &amp;&amp; (arc-&gt;iLexUnit &lt; iVocabularySize));  </span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :                 fLMScores[arc-&gt;iLexUnit] = arc-&gt;fScore;   </span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :                 ++iComputed;</span>
<span class="lineNum">     625 </span>            :         }       
<span class="lineNum">     626 </span>            :         //printf(&quot;computed: %d\n&quot;,iComputed);
<span class="lineNum">     627 </span>            :         
<span class="lineNum">     628 </span>            :         // set lm-score for filler units and sentence markers (0.0)
<span class="lineNum">     629 </span>            :         // that kind of lexical units are after the lexical units for all unigrams
<span class="lineNum">     630 </span>            :         //for(int i=m_iUnigrams ; i &lt; iVocabularySize ; ++i) {
<span class="lineNum">     631 </span>            :                 //fLMScores[i] = 0.0;
<span class="lineNum">     632 </span>            :                 //printf(&quot;lex: %s\n&quot;,m_lexiconManager-&gt;getStrLexUnit(i));
<span class="lineNum">     633 </span>            :         //}
<span class="lineNum">     634 </span>            :         // there may or maynot be unigrams for the unknown symbol and the sentence markers 
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :         fLMScores[m_lexiconManager-&gt;m_lexUnitUnknown-&gt;iLexUnit] = 0.0;</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :         fLMScores[m_lexiconManager-&gt;m_lexUnitBegSentence-&gt;iLexUnit] = 0.0;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         fLMScores[m_lexiconManager-&gt;m_lexUnitEndSentence-&gt;iLexUnit] = 0.0;</span>
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :         // check
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         for(int i=0 ; i &lt; iVocabularySize; ++i) {</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :                 assert(fLMScores[i] != FLT_MAX);</span>
<span class="lineNum">     642 </span>            :         }
<span class="lineNum">     643 </span>            :         
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         delete [] lmArcBackoff;</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :         double dTimeEnd = TimeUtils::getTimeMilliseconds();</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :         BVC_VERB &lt;&lt; &quot;seconds: &quot; &lt;&lt; (dTimeEnd-dTimeBegin)/1000.0 &lt;&lt; &quot; seconds&quot; &lt;&lt; endl;</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 : }</span>
<a name="649"><span class="lineNum">     649 </span>            : </a>
<span class="lineNum">     650 </span>            : // compute the likelihood of the given sequence of words
<span class="lineNum">     651 </span><span class="lineNoCov">          0 : float LMFSM::computeLikelihood(const char *str) {</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :         VLexUnit vLexUnit;</span>
<span class="lineNum">     654 </span>            :         bool bAllKnown;
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         m_lexiconManager-&gt;getLexUnits(str,vLexUnit,bAllKnown);</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :         if (vLexUnit.empty()) {</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                 return -1.0;</span>
<span class="lineNum">     658 </span>            :         }
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         float fLikelihood = 0.0;</span>
<span class="lineNum">     661 </span>            :         float fLikelihoodAux;
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         int iLMState = getInitialState();</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         for(VLexUnit::iterator it = vLexUnit.begin() ; it != vLexUnit.end() ; ++it) {</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :                 iLMState = updateLMState(iLMState,(*it)-&gt;iLexUnit,&amp;fLikelihoodAux);</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :                 fLikelihood += fLikelihoodAux;</span>
<span class="lineNum">     666 </span>            :         }
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :         fLikelihood += toFinalState(iLMState);</span>
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :         return fLikelihood;</span>
<span class="lineNum">     670 </span>            : }
<a name="671"><span class="lineNum">     671 </span>            : </a>
<span class="lineNum">     672 </span>            : // print
<span class="lineNum">     673 </span><span class="lineNoCov">          0 : void LMFSM::print() {</span>
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :         cout &lt;&lt; &quot;-- language model FSM -------------------&quot; &lt;&lt; endl;</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :         cout &lt;&lt; &quot; n-gram order: &quot; &lt;&lt; LMManager::getStrNGram(m_iNGramOrder) &lt;&lt; endl;</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :         cout &lt;&lt; &quot; # states: &quot; &lt;&lt; m_iStates &lt;&lt; endl;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :         cout &lt;&lt; &quot; # arcs:   &quot; &lt;&lt; m_iArcs &lt;&lt; endl;</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :         cout &lt;&lt; &quot;-----------------------------------------&quot; &lt;&lt; endl;      </span>
<a name="680"><span class="lineNum">     680 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineCov">          6 : };      // end-of-namespace</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
